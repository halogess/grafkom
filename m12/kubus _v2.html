<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>WebGL 2.0 Kubus Sederhana</title>
    <style>
      canvas {
        width: 100%;
        height: 100%;
      }
    </style>
    <!-- Pastikan untuk memasukkan glMatrix di sini -->
    <script src="https://cdn.jsdelivr.net/npm/gl-matrix@2.8.1/dist/gl-matrix-min.js"></script>
  </head>
  <body>
    <canvas id="glCanvas"></canvas>
    <script type="text/javascript">
      const canvas = document.getElementById("glCanvas");
      const gl = canvas.getContext("webgl2");

      if (!gl) {
        alert("WebGL 2.0 tidak didukung oleh browser ini.");
      }

      // Mengatur ukuran canvas
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;

      // Vertex shader program
      const vsSource = `#version 300 es
    in vec4 aVertexPosition;
    uniform mat4 uModelViewMatrix;
    uniform mat4 uProjectionMatrix;
    void main() {
        gl_Position = uProjectionMatrix * uModelViewMatrix * aVertexPosition;
    }`;

      // Fragment shader program yang diubah untuk warna merah
      const fsSource = `#version 300 es
    precision highp float;
    out vec4 fragColor;
    void main() {
        fragColor = vec4(1.0, 0.0, 0.0, 1.0); // Warna merah
    }`;

      // Fungsi untuk menginisialisasi shader
      function initShaderProgram(gl, vsSource, fsSource) {
        const vertexShader = gl.createShader(gl.VERTEX_SHADER);
        gl.shaderSource(vertexShader, vsSource);
        gl.compileShader(vertexShader);

        const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(fragmentShader, fsSource);
        gl.compileShader(fragmentShader);

        const shaderProgram = gl.createProgram();
        gl.attachShader(shaderProgram, vertexShader);
        gl.attachShader(shaderProgram, fragmentShader);
        gl.linkProgram(shaderProgram);

        if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
          alert(
            "Tidak dapat menginisialisasi shader program: " +
              gl.getProgramInfoLog(shaderProgram)
          );
          return null;
        }

        return shaderProgram;
      }

      // Inisialisasi shader program
      const shaderProgram = initShaderProgram(gl, vsSource, fsSource);
      if (!shaderProgram) {
        return;
      }

      // Lokasi atribut dan uniform
      const programInfo = {
        attribLocations: {
          vertexPosition: gl.getAttribLocation(
            shaderProgram,
            "aVertexPosition"
          ),
        },
        uniformLocations: {
          projectionMatrix: gl.getUniformLocation(
            shaderProgram,
            "uProjectionMatrix"
          ),
          modelViewMatrix: gl.getUniformLocation(
            shaderProgram,
            "uModelViewMatrix"
          ),
        },
      };

      // Inisialisasi buffer
      function initBuffers(gl) {
        // Membuat buffer posisi untuk kubus
        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);

        // Array posisi vertex untuk kubus
        const positions = [
          // Front face
          -2.0, -2.0, 2.0, 2.0, -2.0, 2.0, 2.0, 2.0, 2.0, -2.0, 2.0, 2.0,

          // Back face
          -2.0, -2.0, -2.0, -2.0, 2.0, -2.0, 2.0, 2.0, -2.0, 2.0, -2.0, -2.0,

          // Top face
          -2.0, 2.0, -2.0, -2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, -2.0,

          // Bottom face
          -2.0, -2.0, -2.0, 2.0, -2.0, -2.0, 2.0, -2.0, 2.0, -2.0, -2.0, 2.0,

          // Right face
          2.0, -2.0, -2.0, 2.0, 2.0, -2.0, 2.0, 2.0, 2.0, 2.0, -2.0, 2.0,

          // Left face
          -2.0, -2.0, -2.0, -2.0, -2.0, 2.0, -2.0, 2.0, 2.0, -2.0, 2.0, -2.0,
        ];

        gl.bufferData(
          gl.ARRAY_BUFFER,
          new Float32Array(positions),
          gl.STATIC_DRAW
        );

        // Membuat buffer untuk indeks kubus
        const indexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);

        // Array indeks yang mendefinisikan setiap wajah kubus
        const indices = [
          // Front face
          0, 1, 2, 0, 2, 3,
          // Back face
          4, 5, 6, 4, 6, 7,
          // Top face
          8, 9, 10, 8, 10, 11,
          // Bottom face
          12, 13, 14, 12, 14, 15,
          // Right face
          16, 17, 18, 16, 18, 19,
          // Left face
          20, 21, 22, 20, 22, 23,
        ];

        gl.bufferData(
          gl.ELEMENT_ARRAY_BUFFER,
          new Uint16Array(indices),
          gl.STATIC_DRAW
        );

        return {
          position: positionBuffer,
          indices: indexBuffer,
        };
      }

      // Inisialisasi buffer
      const buffers = initBuffers(gl);

      // Inisialisasi kamera ortogonal
      const projectionMatrix = mat4.create();
      mat4.ortho(projectionMatrix, -5, 5, -5, 5, 0.1, 100);

      // Inisialisasi model view matrix
      const modelViewMatrix = mat4.create();
      mat4.translate(modelViewMatrix, modelViewMatrix, [0.0, 0.0, -6.0]);

      // Render loop
      function render() {
        gl.clearColor(0.0, 0.0, 0.0, 1.0); // Bersihkan layar dengan warna hitam
        gl.clearDepth(1.0); // Bersihkan segalanya
        gl.enable(gl.DEPTH_TEST); // Aktifkan depth testing
        gl.depthFunc(gl.LEQUAL); // Objek dekat menutupi objek jauh

        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        // Memberitahu WebGL bagaimana mengekstrak posisi dari posisi buffer
        {
          const numComponents = 3; // tarik keluar 3 nilai per iterasi
          const type = gl.FLOAT; // data dalam buffer adalah 32bit float
          const normalize = false; // jangan normalisasi
          const stride = 0; // berapa banyak byte antara satu set nilai ke set berikutnya
          const offset = 0; // berapa banyak byte sejak awal buffer
          gl.bindBuffer(gl.ARRAY_BUFFER, buffers.position);
          gl.vertexAttribPointer(
            programInfo.attribLocations.vertexPosition,
            numComponents,
            type,
            normalize,
            stride,
            offset
          );
          gl.enableVertexAttribArray(
            programInfo.attribLocations.vertexPosition
          );
        }

        // Memberitahu WebGL untuk menggunakan program shader kita saat menggambar
        gl.useProgram(shaderProgram);

        // Mengatur shader uniforms
        gl.uniformMatrix4fv(
          programInfo.uniformLocations.projectionMatrix,
          false,
          projectionMatrix
        );
        gl.uniformMatrix4fv(
          programInfo.uniformLocations.modelViewMatrix,
          false,
          modelViewMatrix
        );

        {
          const vertexCount = 36;
          const type = gl.UNSIGNED_SHORT;
          const offset = 0;
          gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffers.indices);
          gl.drawElements(gl.TRIANGLES, vertexCount, type, offset);
        }

        requestAnimationFrame(render);
      }
      requestAnimationFrame(render);
    </script>
  </body>
</html>
